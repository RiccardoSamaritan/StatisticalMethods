---
title: "Analisi Avanzata del Noleggio Biciclette"
author: "Lorenzo Tonet, Giovanni Oro, Riccardo Samaritan"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: united
    highlight: tango
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.width = 10, fig.height = 7)
library(mgcv)
library(earth)
library(rpart)
library(rpart.plot)
library(ggplot2)
library(dplyr)
library(knitr)
```

```{r data_import}
df = read.csv("hour.csv")

df$season_f = factor(df$season, labels = c("Spring", "Summer", "Autumn", "Winter"))
df$weather_f = factor(df$weathersit, labels = c("Clear", "Cloudy/Mist", 
                                                 "Light Snow/Rain", "Heavy Rain"))
df$workday_f = factor(df$workingday, labels = c("Weekend/Holiday", "Working day"))
df$hr_f = factor(df$hr)
df$weekday_f = factor(df$weekday)
df$yr_f = factor(df$yr, labels = c("2011", "2012"))

cat("Dataset dimensions:", dim(df), "\n")
cat("Variables:", names(df), "\n")

set.seed(6767)

train_id = sample(1:nrow(df), 0.75*nrow(df))
train_data = df[train_id, ]
test_data  = df[-train_id, ]
```


# Introduction and Target

The objective of our analysis is to model **cnt** (total number of rentals). Since we are dealing with count data, the primary challenge is capturing the non-linearity of the hours of the day and the interaction between weather and commuter habits.

# 1. Feature Selection and Model Comparison (GAM)

In this phase, we determine which variables to include. Following the methodology suggested by the course material, we use the **AIC** (Akaike Information Criterion) to balance goodness-of-fit with parsimony.

## 1.1 Model Selection (AIC)

We compare three models of increasing complexity:

* **M1 (Poisson)**: Simple linear effects.
* **M2 (Poisson Smooth)**: Introduces splines for hour (hr) and temperature (temp).
* **M3 (Poisson Interaction)**: Adds the interaction between hour and working day.

```{r model-selection}
# Basic GAM with linear effects (Poisson) - without smooth terms, we take the variables that were presented as significant in the classic linear models
gam_1 <- gam(cnt ~ hr + temp + workday_f + season_f + weather_f + yr_f, family = poisson, data = train_data)
summary(gam_1)

# GAM with spline smooth for hr and temp (Poisson) - captures non-linearity, cyclic cubic spline
gam_2 <- gam(cnt ~ s(hr, bs = "cc", k = 24) + s(temp) + workday_f + season_f + weather_f+ yr_f, family = poisson, data = train_data)
summary(gam_2)

# GAM with hr-workingday interaction (Poisson) - hour effect depends on day type
gam_3 <- gam(cnt ~ s(hr, bs = 'cc', k = 24, by = workday_f) + s(temp) + weather_f + season_f + yr_f, family = poisson, data = train_data)
summary(gam_3)

# GAM Negative Binomial with interaction - handles overdispersion in count data
gam_nb <- gam(cnt ~ s(hr, bs = 'cc', k =24, by = workday_f) + s(temp) + weather_f + season_f + yr_f, family = nb(), data = train_data)
summary(gam_nb)

# AIC Table
aic_results <- data.frame(
  Modello = c("Lineare", "Smooth", "Smooth + Interazione", "NB Smooth + Interazione"),
  AIC = c(AIC(gam_1), AIC(gam_2), AIC(gam_3), AIC(gam_nb))
)
kable(aic_results, caption = "Confronto AIC (Valori piÃ¹ bassi indicano modelli migliori)")
```

## 1.2 ANOVA Test (Analysis of Variance)

To confirm that the more complex model (M3) is indeed necessary, we perform an ANOVA test. (Note: this could also be performed on the other models, but it would be redundant.)

```{r anova-test}
anova(gam_2, gam_3, test = "Chisq")
```

The extremely low p-value indicates that the interaction is statistically significant. It is a necessary component of the model.

# 2. Visual Analysis of the Models

## 2.1 Residual Diagnostics (Linear Model)

```{r diagnostic-lm}
# Standard Linear Model including all factors - baseline for comparison
lm_full <- lm(cnt ~ hr + temp + workday_f + weather_f + season_f + yr_f, data = train_data)
summary(lm_full)
par(mfrow = c(2, 2))
plot(lm_full, main = "LM Diagnostics")

```

## 2.2 Smooth Effects Plot(GAM)

```{r gam-effects}
# NB GAM with cyclic spline for hr - cyclic smooth to capture the 24h daily pattern
gam_final_ciclica <- gam(cnt ~ s(hr, bs = 'cc', k = 24) + weather_f + season_f + yr_f, family = nb(), data = train_data)
summary(gam_final_ciclica)

# GAM without cyclic constraint for comparison
gam_final_no <- gam(cnt ~ s(hr) + weather_f + yr_f, family = nb(), data = train_data)
summary(gam_final_no)

par(mfrow = c(1, 2))
plot(gam_final_ciclica, select = 1, main = "Cyclic Spline (hr)")
plot(gam_final_no, select = 1, main = "Spline Effect")
```

## 2.3 3D Interaction Visualization

```{r 3d-interaction}
# NB GAM with hr-workday interaction for 3D surface - visualizes differentiated patterns (best model)
# Model without year
gam_interaction <- gam(cnt ~ s(hr, bs = 'cc', k = 24, by = workday_f) + 
                        s(temp) + weather_f + season_f, 
                       family = nb(), data = train_data)
summary(gam_interaction)

# Visualizing the response surface: Hour vs. Temperature
vis.gam(gam_interaction, view = c("hr", "temp"), 
        plot.type = "persp", 
        theta = 140, phi = 30, color = "terrain",
        main = "Response Surface: Hour vs Temperature")
```

```{r}
# Optimal model including the year variable
gam_interaction_year <- gam(cnt ~ s(hr, bs = 'cc', k = 24, by = workday_f) + 
                        s(temp) + weather_f + season_f + yr_f, family = nb(), data = train_data)
summary(gam_interaction_year)

# Comparing models via ANOVA
anova(gam_interaction, gam_interaction_year, test = "Chisq")

# Performance Metrics: MSE and RMSE and R^2
# Function to calculate evaluation metrics
get_metrics <- function(model, data, target_col) {
  actual <- data[[target_col]]
  # Use type = "response" to obtain predicted counts (not the log)
  pred <- predict(model, newdata = data, type = "response")
  
  aic_test <- AIC(model)
  mse  <- mean((actual - pred)^2)
  rmse <- sqrt(mse)
  r2   <- 1 - (sum((actual - pred)^2) / sum((actual - mean(actual))^2))
  
  return(c(AIC = aic_test, MSE = mse, RMSE = rmse, R2 = r2))
}

# Calculate metrics for both models
metrics_best <- get_metrics(gam_interaction, test_data, "cnt")
metrics_year <- get_metrics(gam_interaction_year, test_data, "cnt")

# Create a comparison table
performance_comparison <- data.frame(
  Model = c("Without Year (Best)", "With Year (Year)"),
  rbind(metrics_best, metrics_year)
)

print(performance_comparison)

# 3D Visualization of the interaction in the year model
vis.gam(gam_interaction_year, view = c("hr", "temp"), 
        plot.type = "persp", 
        theta = 140, phi = 30, color = "terrain",
        main = "Response Surface: Hour vs Temperature")

```

```{r}
# GAM including year but without interaction for comparison
gam_year_no_int <- gam(cnt ~ s(hr, bs = 'cc', k = 24) + 
                        s(temp) + weather_f + season_f + yr_f, family = nb(), data = train_data)
AIC(gam_year_no_int)

# Plotting specific smooth terms
par(mfrow = c(1, 2))
plot(gam_year_no_int, select = 1, main = "Cyclic Spline (hr) without Interaction")
plot(gam_year_no_int, select = 2, main = "Spline (temp) without Interaction")
```


Here is the professional English translation for your section on alternative models and Cross-Validation.

---

# 3. Alternative Models and Machine Learning

## 3.1 MARS (Automated Feature Selection)

MARS automatically identifies critical "hinge points" (nodes) for variables and handles complex interactions without manual specification.

```{r mars-model}
# MARS with degree=2 - Uses Multivariate Adaptive Regression Splines for automated interactions
mars_model <- earth(cnt ~ hr + temp + workday_f + weather_f + season_f + yr_f, data = train_data, degree = 2)

# MARS model summary
summary(mars_model)
# Plot of variable selection performance
plot(mars_model, which = 1, main = "MARS Variable Selection (GCV)")

```

```{r}

# MARS model without interactions (additive only, degree = 1)
mars_model_no_int <- earth(cnt ~ hr + temp + workday_f + weather_f + season_f + yr_f, data = train_data, degree = 1)

# MARS model excluding the 'hour' variable
mars_model_no_hr <- earth(cnt ~ temp + workday_f + weather_f + season_f + yr_f, data = train_data, degree = 2)

# Calculate GCV for all three models
gcv1 <- mars_model$gcv
gcv2 <- mars_model_no_int$gcv
gcv3 <- mars_model_no_hr$gcv

# Comparative table
mars_comparison <- data.frame(
  Model = c("MARS without Interactions", "MARS without Hour", "MARS with Interactions"),
  GCV = c(gcv2, gcv3, gcv1)  # Order: no_int, no_hr, with_int
)
kable(mars_comparison, caption = "GCV Comparison for MARS Models")

```

```{r CV}
# Compare models based on point-predictive capability using RMSE and MAE via Cross-Validation
library(dplyr)

# Create 5 folds for CV
set.seed(6767)
folds <- sample(rep(1:5, length.out = nrow(train_data)))

# Initialize result vectors
rmse_mars <- numeric(5)
rmse_gam  <- numeric(5)

mae_mars <- numeric(5)
mae_gam  <- numeric(5)

for(i in 1:5) {
  # Internal Train/Validation split
  val_idx <- which(folds == i)
  cv_train <- train_data[-val_idx, ]
  cv_val   <- train_data[val_idx, ]
  
  # Fit MARS
  m_mars <- earth(cnt ~ hr + temp + workday_f + weather_f + season_f + yr_f, 
                  data = cv_train, degree = 2)
  
  # Fit GAM (utilizing REML for a more robust Negative Binomial estimation)
  m_gam <- gam(cnt ~ s(hr, bs = 'cc', k = 24, by = workday_f) + s(temp) + 
               weather_f + yr_f, family = nb(), data = cv_train, method = "REML")
  
  # Predictions
  pred_mars <- predict(m_mars, newdata = cv_val)
  pred_gam  <- predict(m_gam, newdata = cv_val, type = "response")
  
  # Calculate RMSE
  rmse_mars[i] <- sqrt(mean((cv_val$cnt - pred_mars)^2))
  rmse_gam[i]  <- sqrt(mean((cv_val$cnt - pred_gam)^2))
  
  # Calculate MAE
  mae_mars[i] <- mean(abs(cv_val$cnt - pred_mars))
  mae_gam[i]  <- mean(abs(cv_val$cnt - pred_gam))
}

# Final Results: Average RMSE and average MAE
cat('MARS Mean RMSE:', mean(rmse_mars), '\n')
cat('GAM Mean RMSE:', mean(rmse_gam), '\n')

cat('MARS Mean MAE:', mean(mae_mars), '\n')
cat('GAM Mean MAE:', mean(mae_gam), '\n')

# Visual verification of model assumptions
par(mfrow = c(1, 2))
plot(pred_mars, cv_val$cnt - pred_mars, main="MARS Residuals", xlab="Predicted", ylab="Residuals") # Checking Homoscedasticity
plot(pred_gam, cv_val$cnt - pred_gam, main="GAM Residuals", xlab="Predicted", ylab="Residuals")    # Checking for Quadratic Heteroscedasticity

```

```{r visualization-gam-splines}
# Visualization of smooth effects for the 'gam_interaction_year' model
plot(gam_interaction_year, select = 1, main = "Spline Effect (hr) - Holidays/Weekends")
plot(gam_interaction_year, select = 2, main = "Spline Effect (hr) - Working Days")
plot(gam_interaction_year, select = 3, main = "Spline Effect (temp)")

# Interpretation:
# select = 1: Hourly spline for the first level of workday_f (Weekends/Holidays).
# select = 2: Hourly spline for the second level of workday_f (Working Days).
# select = 3: Temperature spline s(temp).

```

# 4. Final Evaluation on Test Set (Metrics)

```{r final-evaluation}
# Metrics calculation function
calc_metrics <- function(actual, pred) {
  mse <- mean((actual - pred)^2)
  rmse <- sqrt(mse)
  r2 <- 1 - (sum((actual - pred)^2) / sum((actual - mean(actual))^2))
  return(c(MSE = mse, RMSE = rmse, R2 = r2))
}

# Test set predictions for all models
p_lm           <- predict(lm_full, test_data)
p_gam1         <- predict(gam_1, test_data, type = "response")
p_gam2         <- predict(gam_2, test_data, type = "response")
p_gam3         <- predict(gam_3, test_data, type = "response")
p_gam_nb       <- predict(gam_nb, test_data, type = "response")
p_gam_ciclica  <- predict(gam_final_ciclica, test_data, type = "response")
p_gam_no_ciclica <- predict(gam_final_no, test_data, type = "response")
p_gam_interaction <- predict(gam_interaction, test_data, type = "response")
p_mars         <- predict(mars_model, test_data)

# Comparative Table including ALL generated models
comparison <- rbind(
  "Linear Model" = calc_metrics(test_data$cnt, p_lm),
  "GAM (Linear Poisson)" = calc_metrics(test_data$cnt, p_gam1),
  "GAM (Smooth Poisson)" = calc_metrics(test_data$cnt, p_gam2),
  "GAM (Smooth + Interaction Poisson)" = calc_metrics(test_data$cnt, p_gam3),
  "GAM (NB Interaction)" = calc_metrics(test_data$cnt, p_gam_nb),
  "GAM (NB Cyclic)" = calc_metrics(test_data$cnt, p_gam_ciclica),
  "GAM (NB Non-Cyclic)" = calc_metrics(test_data$cnt, p_gam_no_ciclica),
  "GAM (NB 3D Interaction)" = calc_metrics(test_data$cnt, p_gam_interaction),
  "MARS"          = calc_metrics(test_data$cnt, p_mars)
)

kable(round(comparison, 3), caption = "Final Performance on the Test Set")

```
